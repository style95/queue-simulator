package style95

import akka.actor.{Actor, ActorRef, PoisonPill, Props, Timers}
import style95.Container.ContainerProperty

import scala.concurrent.duration._

object Container {
  final case class ActivationMessage(
      requester: ActorRef, // the sender of this activation message, used for routing
      userStart: Long, // (nano timestamp) when the request was generated by user
      invokeStart: Long // (nano timestamp) when the request was sent to a container
  ) {
    def invokeAt(t: Long): ActivationMessage =
      ActivationMessage(requester, userStart, t)
  }

  final case class WorkDone(message: ActivationMessage)

  final case class ContainerStatus(ready: Boolean)

  final case object ContainerCreated

  final case class ContainerProperty(initialDelay: FiniteDuration,
                                     execTime: FiniteDuration)

  // a message to instrument a graceful shutdown
  final case object StopContainer

  final case object ContainerStopped

  private case object DelayKey

  private case class DelayMsg(msg: ActivationMessage)

  def props(simulator: ActorRef, property: ContainerProperty): Props =
    Props(new Container(simulator, property))
}

class Container(val simulator: ActorRef, property: ContainerProperty)
    extends Actor
    with Timers {

  import Container._
  import context.{system, dispatcher}

  private var tombStone = false

  system.scheduler.scheduleOnce(property.initialDelay) {
    simulator ! ContainerCreated
  }

  override def receive: Receive = {
    case msg: ActivationMessage =>
      timers.startSingleTimer(DelayKey, DelayMsg(msg), property.execTime)
    case DelayMsg(msg) =>
      simulator ! WorkDone(msg)
      if (tombStone) {
        simulator ! ContainerStopped
        self ! PoisonPill
      }
    case StopContainer => tombStone = true
  }
}
